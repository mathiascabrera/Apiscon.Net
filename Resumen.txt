Curso de APIs con .NET



**********      INTRODUCCION      **********


Obtendremos todos los conocimientos necesarios para crear nuestros propios APIs utilizando .NET

Arrancaremos viendo el concepto de REST ó patrón de REST, ya que este es el concepto que utiliza internamente el template de API de .NET para su funcionamiento.

Luego de ello analizaremos algunos aspectos de las arquitecturas dentro de las APIs, como lo es el concepto de Login, Inyección de Dependencia, Swagger, y los Middlewares, esta ultima son las bases del funcionamiento de las APIs con .NET.

Posterior a ello crearemos un proyecto muy parecido a lo que sería un proyecto real utilizando 2 modelos:
un modelo de tareas, un modelo de categorias, y una configuración de Entity Framework.

Utilizaremos Entity Framework para conectarnos a una bd real. Para ello podremos optar por SQL Server y PostgresSQL.


Una vez adquirido todos estos conocimientos, estaremos listos para crear nuestras propias APIs.

Es importante tomar el curso de Entity Framework antes de tomar este curso.
Es una librería que utilizaremos para poder conectarnos a una base de datos real y poder completar todos los ejercicios del curso.










**********      ¿Qué es una API?      **********

Application Programming Interface

Es una aplicacion que nos permite crear una capa de abstracción o una interface entre una aplicacion y otra.

Es un proveedor de métodos y funciones hacia otras aplicaciones.

Encapsulamos una lógica dentro de una aplicación que será consumida por otra, y tiene que pasar a través de una capa de abstracción para poder realizar este consumo.

Esta capa de abstraccion nos permite que la API pueda ser consumida por cualquier tipo de cliente, incluso si no está desarrollado en el mismo lenguaje de programación o con la misma tecnología. Esto es lo MAS RESALTANTE de una API, y esta es la razón por la que se utiliza tanto en la industria del desarrollo de software y es una de las cuestiones que debe saber un desarrollador backend.


Tambien la API puede poseer capas adicionales de seguridad, autorizacion y autenticación nos permitiran determinar qué pueden ver el usuario y qué puede ejecutar cuando esté consumiendo una API.




Arquitectura comun en una aplicacion Cliente Servidor (página 7 pdf).

El cliente podría ser una aplicacion web creada en REACT en Angular o tambien una App que puede ser desarrollada en Flutter o Xamarin, o tambien podría ser una aplicacion de escritorio.

Al final este cliente tendrá que consumir una API, que sería nuestro Backend o nuestro Servidor de Backend que va a tener toda la lógica que este cliente necesita y va a servir como una capa de abstracción entre el cliente y todas las acciones que nosotros queremos realizar en la base de datos.
Esto va a permitir que nuestra aplicación sea mucho mas segura y que nosotros nos encargemos en nuestra API de hacer la gestión de todo lo que el cliente quiere hacer.
Al final el cliente no se va a enterar que exactamente de qué está haciendo la aplicación, simplemente va a recibir notificaciones de qué lo hizo, o qué fué lo que pasó.


Es muy importante mencionar que una API puede consumir otras APIS. De hecho esto es muy común en una aplicación real.


Uno de los ejemplos de Api del pdf es la de Almacenamiento de archivos, como lo es la de Azure o AWS. Que nos permiten guardar archivos de texto, documentos, imágenes, videos, etc.
La API es la que se va a encargar de realizar esta comunicación.

También podemos consumir Sericios de Pagos, como por ejemplo la de PayPal o Stripe que nos van a permitir manejar los pagos y consumos que esté generando el Usuario dentro de la aplicación.

También podríamos realizar una Autenticación de la API utilizando otras APIs de otros proveedores como podrian ser la API de Facebook y la API de Google. Es bastante común en aplicaciones modernas que podamos usar nuestra cuenta de Google de Facebook y otras cuentas para realizar el proceso de autenticación dentro de una aplicación.











**********      ¿Qué es REST?      **********

API REST es la combinación de las dos definiciones, para poder crear APIs que sigan un único estándar, que en este caso sería el estándar de Rest.

REST = Representational state transfer.

- Estilo de arquitectura para el diseño de interfaces web.
Esto significa que tanto API como REST no son implementaciones o tecnologías que podamos descargar e instalar en nuestro ordenador.
Basicamente son solo conceptos teóricos que debemos aplicar al momento en el que estemos escribiendo o estructurando nuestro proyecto.

- Permite el manejo de recursos desde el lado del servidor.
REST posee toda una serie de reglas que nosotros debemos seguir, permitiendonos manejar los recursos en todas las situaciones en las que debamos manejar o controlar recursos.

- REST es muy bueno ya que nos permite obtener un alto rendimiento, una buena escalabilidad,  mucha simplicidad a la hora de codificar nuestra API y mucha confiabilidad.


Basicamente Rest es un patrón que ya está comprobado, que funciona, y que se aplica a la gran mayoría de API que se construyen al día de hoy. 





PÁGINA 11: HTTP VERBS

Una de las reglas de REST es que debemos utilizar unos VERBS o unos verbos al momento en que hacemos un llamado HTTP para indicar a la API cuál es la acción que necesitamos ejecutar.

Si necesitamos Obtener y Leer recursos que se encuentran dentro del Servidor, sean recursos que esten en una base de datos o en un archivo debemos utilizar el VERBO GET.

Si necesitamos CREAR o realizar la inserción de un recurso de algún dato debemos utilizar el VERBO POST.

Si necesitamos realizar la ACTUALIZACION DE UN REGISTRO, debemos utilizar el método PUT.

Si necesitamos realizar la ACTUALIZACIÓN PARCIAL de un registro (es decir, actualizar solamente por ejemplo un campo o una columna de una tabla), utilizaremos el método PATCH.

Si necesitamos ELIMINAR un Registro, haremos uso del método DELETE.

Estos son los VERBOS mas utilizados para poder realizar acciones con recursos en base de datos o del lado del servidor en un API, pero existen tambien otros muy importantes.






PÁGINA 12: Manejo de URLs

Otra regla es la de manejar una URL por cada recurso que tengamos en la base de datos, esta URL nos va a permitir realzar las acciones que deseemos con este recurso, pero esta URL no puede ser dinámica, no puede cambiar y además debe indicar cuál es el recurso al que estamos accediendo.

Ejemplo: /api/usuarios/1

En este caso se está accediendo por ejemplo a la api, y a algun recurso como podría ser una tabla, el 1 al final indica el recurso 1 dentro de la tabla usuarios.

Esta URL no va a cambiar, y es la misma url que vamos a utilizar para todas las acciones que queramos realizar con este recurso. Si queremos eliminarlo, si queremos actualizarlo, si queremos obtenerlo vamos a tener que utilizar esta misma URL.





PAGINA 13 : RESPUESTAS HTTP

Por ultimo, Rest posee una serie de respuestas que nosotros debemos manejar para poder notificar al usuario de lo que está ocurriendo en nuestra API. Esto también nos permite manejar un estándar porque el concepto de API no nos dice qué es lo quedemos de devolver ya que simplemente estamos interactuando una aplicacion con otra, REST nos ayuda a poder manejar un estándar para poder manejar el tema de respuestas y comunicación entre una aplicación cliente y un servidor.

Tenemos diferentes respuestas que podemos manejar en una API REST:

- Respuestas Informativas (100 - 199), los códigos que van desde los 100 hasta los 199.

- Respuestas Satisfactorias (200 - 299), ESTAS SON LAS RESPUESTAS MAS UTILIZADAS.

- Redirecciones (300 - 399)

- Errores de los clientes (400 - 499), ALTAMENTE UTILIZADOS TAMBIÉN.

- Errores de los servidores (500 - 599) , ALTAMENTE UTILIZADOS TAMBIÉN ya que normalmente vamos a obtener este tipo de errores si existe una mala configuracion o un error interno dentro de la API.


Las respuestas mas utilizadas que podemos resaltar son 500 Internal Error que significa que ocurri+o un error interno dentro del Servidor, generalmente es un error no controlado, es decir, es algo que no debió pasar en el servidor pero que de alguna manera nunca se controló y nos devuelve un error y no puede controlar la accion que le estemos solicitando a nuestra API.



200 es el codigo exitoso, es el mas utilizado y es lo que esperamos que siempre ocurra dentro de una aplicacion indicando que todo esta funcionando bien.



NOT FOUND significa que el recurso no fue encontrado. Es bastante común también .



201 que indica que se ha creado un recurso, tambien es altamente utilizado.


204 el no content, que todo se realizó bien pero que no hay contenido para devolver. Esto se utiliza cuando se realiza tareas de actualizacion o cuando se realizan cambios dentro del servidor.











**********      Creando tu primera API con .NET      **********

Comandos desde la consola:

Una vez situado en la carpeta que vamos a utilizar para el proyecto podemos ejecutar los siguientes comandos:

° dotnet new = crea un proyecto de .NET basado en una plantilla.

Con este comando podemos crear diferentes proyectos, no solo APIs, sino tambien PROYECTOS DE CONSOLA, PROYECTOS PARA WINDOWS, PROYECTOS DE BLAZOR.


° dotnet new --list = para visualizar todas las planillas.

Desglozandose el listado, el comando que vamos a utilizar es "webapi"

Tambien existe otro diferente que es el "web" que permite crear una web api utilizando mínima la api, que es un concepto nuevo que posee .NET, sin embargo el TEMPLATE Clásico y el más completo es el "webapi"


Procedemos, desde la consola, a ejecutar el comando "dotnet new webapi" para que se cree nuestro proyecto.


Luego si deseamos abrir el proyecto con VScode desde la terminal podemos hacerlo con "code ." siempre y cuando estemos situados en el directorio correcto.


En la próxima sesión utilizaremos POSTMAN para poder analizar el ENDPOINT o la URL que trae por defecto la API, que sería como el DEMO que trae la API para que podamos jugar con ella y entender cómo funciona.











**********      Consumiendo API desde Postman      **********



15 extensiones indispensables para programar con C# y .NET Core

https://marketplace.visualstudio.com/items?itemName=jolhe.csharp-netcore-extensionpack

En esta clase ejecutaremos el proyecto que hemos creado anteriormente y utilizaremos POSTMAN para comprobar el funcionamiento de nuestra API.


Primeramente abrimos una nueva terminal para ejecutar el proyecto

ejecutamos el comando dotnet run

Al ejecutarlo nos saldrá los links a los cuales podremos consumir nuestra API.

Copiamos uno de los links (preferentemente la de https - con certificados seguros), y nos dirigimos a Postman.

Al abrir Postman agregamos un nuevo "Request" con el boton de "+".

Primero se determina qué acción o verbo realizar sobre la API, en este caso vamos a utilizar GET.

Luego pegamos el link que copiamos de VSCODE.

Una vez ingresada la direccion le damos click a SEND.

Al presionar SEND salta en STATUS "404 Not Found"

Lo cual quiere decir que la ruta a la que queremos acceder no posee ningún contenido, o no posee ninguna acción dentro de la API.

Por lo que debemos fijarnos dentro de la API cuál es la ruta a la que debemos acceder para realizar alguna acción.


Entonces volvemos a VSCODE.

Revisamos la carpeta "Controllers", esta carpeta contiene todas las clases que realizan el manejo de los request dentro de la API.

Alli nos fijamos en la instruccion ROUTE , para saber qué ruta utilizar para consumir el Endpoint.
En este caso recibe el mismo nombre del controlador "WeatherForecast", por lo que volvemos a Postman y a la direccion que ya habiamos copiado anteriormente le agregamos una barra y el nombre de la ruta ("WeatherForecast").

Quedando, por ejemplo : http://localhost:5087/WeatherForecast

Y volvemos a darle click a SEND.












**********      Análisis del Template para APIs de .NET      **********

Veamos un concepto fundamental "MVC"

Estas siglas significan:

MODEL = Datos
VIEW = Interfaz de usuario
Controller = Lógica

Es un Modelo Arquitectónico, MODELO VISTA CONTROLADOR ó MODEL CONTROLLER VIEW.

Es altamente utilizado dentro del desarrollo de software.

Nos ayuda a poder realizar una separacion de responsabilidades dentro de la estructura de nuestro proyecto.

La idea es crear "modelos" que son clases en la POO que nos permitiran almacenar los datos que nosotros en ese momento estemos manejando o que el usuario esté visualizando en ese momento a través de la VIEW.

La VIEW es esa Interfaz que va a tener nuestra aplicación para entenderse o comunicarse con el usuario.

El CONTROLLER maneja toda la lógica que se pueda presentar dentro de la interacción del usuario con la vista, por ejemplo al hacer click en un botón de "Guardar", cada una de las interacciones seran manejadas por los controladores.


ESTE PATRÓN ESTÁ MUY LIGADO AL DESARROLLO WEB ó APLICACIONES WEB.



En el caso del Template WEBAPI es eliminar la parte de la vista, es decir pasamos de MVC a MC:
MODEL (para almacenar los datos) y CONTROLLER (para manejar la lógica).

Recordemos que una API no tiene una interfaz de usuario, simplemente es una capa abstracta que permite que interactuemos con ella a través del patrón REST.

Lo común es que otros clientes, u otras APIS consuman los datos o ejecuten las diferentes funcionalidades que posee nuestra API.




VEAMOS LA ESTRUCTURA DEL PROYECTO QUE TENEMOS EN VISUAL STUDIO

"Todos los controladores deben almacenarse en la carpeta CONTROLLERS"

Por defecto, dentro de esta carpeta viene una clase llamada "WeatherForecastController"

Si nuestro proyecto tiene que manejar usuarios, procesos, areas, empleados, productos etc, lo que debemos realizar es crear un controlador para cada uno de esos modelos.

CADA MODELO CREADO DEBE TENER SU PROPIO CONTROLADOR.

Por ejemplo el MODELO WeatherForecast.cs tiene su CONTROLLADOR "WeatherForecastController.cs"


El modelo WeatherForecast.cs básicamente es una clase que posee cada una de las propiedades que necesita el demo para poder alojar la información, y WeatherForecastController.cs es el encargado de manejar toda la lógica poder devolver o retornar los datos y exponer todas las funciones que afecten de alguna manera el modelo WeatherForecast.cs


Es muy importante, para los controladores, agregar al final del nombre "Controller" como lo tenemos en el ejemplo: WeatherForecastController.cs


Además de esto, los controladores, deben heredar de ControllerBase que nos brinda todas las funciones que necesitamos para poder realizar todos los códigos de respuesta que normalmente se debería de responder, utilizando el patrón REST.


Otro archivo importante es la del proyecto con extensión .csproj

El TargetFramework es donde se define la versión del Framework

El SDK para el caso de WEBAPI siempre será web

El SDK posee una serie de librerías base que necesitamos para trabajar con alguna tecnología en particular.
En este caso la tecnología que vamos a manejar es ASP.NET que nos permite manejar requerimientos o peticiones http que son las que utilizan las Apis Rest.

el siguiente código:
<ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="7.0.10" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

Es un paquete que nos permite trabajar con ASP.NETCORE, y es el paquete que contiene la documentacion de "Swagger" que ya veremos qué es y para qué sirve, pero básicamente nos ayuda a generar la documentación de nuestra API.




PROGRAM.cs es el archivo que posee toda la configuración del proyecto y la forma en la que se va a ejecutar.




Por último, tenemos los archivos "appsettings.json" que por defecto crean el "appsettings.Development.json" y el"appsettings.json" que contiene todas las opciones para poder configurar nuestro proyecto.


Normalmente, en "appsettings.Development.json" vamos a almacenar la conexion a una base de datos, contraseñas, tockens de acceso para servicios en la nube, etc.



Luego dentro de la carpeta "Properties" se encuentra el archivo "launchSettings.json" que contiene como se va a ejecutar la API.

Siempre por defecto tiene dos perfiles: "webapi" y "IIS Express"













**********      Atributos para verbos HTTP      **********

¿Cómo podemos utilizar los verbos http dentro de nuestro proyecto?

Para realizar esto utilizaremos los Atributos que existen dentro de .NET

Nos permiten marcar en una función cuál es el verbo que queremos utilizar.


Vayamos para el código, lo primero que vamos a realizar es el método POST (para poder agregar un registro), en el archivo "WeatherForecastController.cs".



Alli creamos una nueva propiedad a la clase :

private static List<WeatherForecast> ListWeatherForecast = new List<WeatherForecast>();




Luego en el constructor de la clase le asignamos una serie de registros:


public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
        _logger = logger;
        /* El método Any devuelve un booleano, determina si tiene elementos u registros. En este caso en la condicion del if es si no tiene ningún registro. */
        if (ListWeatherForecast == null || !ListWeatherForecast.Any())
        {
            ListWeatherForecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                TemperatureC = Random.Shared.Next(-20, 55),
                Summary = Summaries[Random.Shared.Next(Summaries.Length)]
            })
        .ToList();
        }
    }





Al http get lo modificamos, ahora va a retornar la lista entera pero ya creada, a diferencia de la anterior, que por cada vez que de ejecutaba el método GET se creaban los registros aleatorios (Randoms), y luego los retornaba.

Asi quedó luego de las modificaciones:

[HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable<WeatherForecast> Get()
    {
        return ListWeatherForecast;

    }





Tambien creamos los métodos para POST y DELETE.


    /* Metodo POST: */
    [HttpPost]
    public IActionResult Post(WeatherForecast weatherForecast)
    {
        ListWeatherForecast.Add(weatherForecast);
        return Ok();
    }

    /* Metodo DELET: */
    [HttpDelete]
    public IActionResult Delete(int index)
    {
        ListWeatherForecast.RemoveAt(index);
        return Ok();

    }





Luego abrimos una nueva terminal y ejecutamos el proyecto.

Ejecutamos dotnet run
copiamos la url

Luego nos dirigimos a Postman, agregamos una nueva ventana, pegamos la url con el verbo POST, le damos click a Body / raw y en vez de "Text" que viene por defecto, elegimos JSON, que es el formato por el cual vamos a pasar los datos.

ESTA ES LA MANERA MÁS COMÚN DE PASAR LOS DATOS, ya que el formato JSON es el estándar.

Copiamos un fragmento del JSON que habiamos ejecutado en la ventana anterior en POSTMAN.

Por ejemplo este fragmento de JSON :

 {
        "date": "2023-12-09",
        "temperatureC": -14,
        "temperatureF": 7,
        "summary": "Warm"
    }




Para el DELETE, desde Postman, utilizamos la url "http://localhost:5087/WeatherForecast/1" en donde el 1 es el numero del indice que deseamos eliminar.














**********      Manejo de Rutas      **********


Aprendamos un poco mas respecto del manejo de las rutas utilizando el controlador que viene por defecto "WeatherForecastController".

Este código:
[Route("[controller]")]
es el que nos permite definir el enrutamiento de nuestro Controlador.


el [controller] define que es una ruta dinámica, si cambia el nombre del Controlador, entonces la ruta también se va a modificar.


Tambien podríamos agregar caracteres que sean estáticos, como por ejemplo:

[Route("api/[controller]")]

De manera que en este caso api queda fijo y el nombre dinámico del controlador para poder armar la ruta y acceder a los recursos.


Ahora abrimos una nueva terminal y ejecutamos "dotnet run", copiamos la url.

Si nos vamos a Postman e intentamos volver a ejecutar el GET de la clase anterior (sin cambiar nada), va a devolver error (404 Not Found), esto se debe a que la ruta para acceder al controlador ya no es la misma.

Antes era : http://localhost:5087/WeatherForecast

Mientras que ahora es : http://localhost:5087/api/WeatherForecast



Asi como podemos realizar el enrutamiento a nivel de Controlador, también podemos hacerlo a nivel de las acciones o métodos dentro del Controlador.

Por ejemplo al verbo GET podemos agregarle la ruta:
[Route("Get/weatherforecast")]

en este caso estamos especificando que la ruta dentro del Controlador ("api/[controller]"), tenemos que agregarle "Get/weatherforecast" para poder acceder al método GET.

Ejecutamos el dotnet run y verificamos esto en Postman.


Al irnos a Postman y ejecutamos el Verbo GET con la url http://localhost:5087/api/WeatherForecast va a funcionar igual ya que es el único método GET del Controlador.

Aún así si ejecutamos "http://localhost:5087/api/WeatherForecast/Get/weatherforecast" con el enrutamiento que recién definimos, también va a funcionar.




Podemos tener múltiples rutas para una acción.
Por ejemplo, recien creamos una ruta para el Verbo GET (  [Route("Get/weatherforecast")] )
Ahora podemos agregar una ruta adicional:   [Route("Get/weatherforecast2")]




También podemos utilizar una PALABRA DINÁMICA a la hora de enrutar acciones.

Para ello utilizamos la palabra [action]. Para los controladores utilizamos [controller].

Esto nos permite utilizar el nombre que tenga el método para realizar el llamado del endopoint.

De esta forma en Postman el GET se puede ejecutar de las siguientes maneras:

http://localhost:5087/api/WeatherForecast/Get/weatherforecast

http://localhost:5087/api/WeatherForecast/Get/weatherforecast2

http://localhost:5087/api/WeatherForecast/Get

Si cambiamos el nombre del metodo GET (desde VSCODE), entonces desde Postman tambien va a cambiar.


link ENRUTAMIENTO DE ATRIBUTOS : https://learn.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2

































































































