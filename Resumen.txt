Curso de APIs con .NET



**********      INTRODUCCION      **********


Obtendremos todos los conocimientos necesarios para crear nuestros propios APIs utilizando .NET

Arrancaremos viendo el concepto de REST ó patrón de REST, ya que este es el concepto que utiliza internamente el template de API de .NET para su funcionamiento.

Luego de ello analizaremos algunos aspectos de las arquitecturas dentro de las APIs, como lo es el concepto de Login, Inyección de Dependencia, Swagger, y los Middlewares, esta ultima son las bases del funcionamiento de las APIs con .NET.

Posterior a ello crearemos un proyecto muy parecido a lo que sería un proyecto real utilizando 2 modelos:
un modelo de tareas, un modelo de categorias, y una configuración de Entity Framework.

Utilizaremos Entity Framework para conectarnos a una bd real. Para ello podremos optar por SQL Server y PostgresSQL.


Una vez adquirido todos estos conocimientos, estaremos listos para crear nuestras propias APIs.

Es importante tomar el curso de Entity Framework antes de tomar este curso.
Es una librería que utilizaremos para poder conectarnos a una base de datos real y poder completar todos los ejercicios del curso.










**********      ¿Qué es una API?      **********

Application Programming Interface

Es una aplicacion que nos permite crear una capa de abstracción o una interface entre una aplicacion y otra.

Es un proveedor de métodos y funciones hacia otras aplicaciones.

Encapsulamos una lógica dentro de una aplicación que será consumida por otra, y tiene que pasar a través de una capa de abstracción para poder realizar este consumo.

Esta capa de abstraccion nos permite que la API pueda ser consumida por cualquier tipo de cliente, incluso si no está desarrollado en el mismo lenguaje de programación o con la misma tecnología. Esto es lo MAS RESALTANTE de una API, y esta es la razón por la que se utiliza tanto en la industria del desarrollo de software y es una de las cuestiones que debe saber un desarrollador backend.


Tambien la API puede poseer capas adicionales de seguridad, autorizacion y autenticación nos permitiran determinar qué pueden ver el usuario y qué puede ejecutar cuando esté consumiendo una API.




Arquitectura comun en una aplicacion Cliente Servidor (página 7 pdf).

El cliente podría ser una aplicacion web creada en REACT en Angular o tambien una App que puede ser desarrollada en Flutter o Xamarin, o tambien podría ser una aplicacion de escritorio.

Al final este cliente tendrá que consumir una API, que sería nuestro Backend o nuestro Servidor de Backend que va a tener toda la lógica que este cliente necesita y va a servir como una capa de abstracción entre el cliente y todas las acciones que nosotros queremos realizar en la base de datos.
Esto va a permitir que nuestra aplicación sea mucho mas segura y que nosotros nos encargemos en nuestra API de hacer la gestión de todo lo que el cliente quiere hacer.
Al final el cliente no se va a enterar que exactamente de qué está haciendo la aplicación, simplemente va a recibir notificaciones de qué lo hizo, o qué fué lo que pasó.


Es muy importante mencionar que una API puede consumir otras APIS. De hecho esto es muy común en una aplicación real.


Uno de los ejemplos de Api del pdf es la de Almacenamiento de archivos, como lo es la de Azure o AWS. Que nos permiten guardar archivos de texto, documentos, imágenes, videos, etc.
La API es la que se va a encargar de realizar esta comunicación.

También podemos consumir Sericios de Pagos, como por ejemplo la de PayPal o Stripe que nos van a permitir manejar los pagos y consumos que esté generando el Usuario dentro de la aplicación.

También podríamos realizar una Autenticación de la API utilizando otras APIs de otros proveedores como podrian ser la API de Facebook y la API de Google. Es bastante común en aplicaciones modernas que podamos usar nuestra cuenta de Google de Facebook y otras cuentas para realizar el proceso de autenticación dentro de una aplicación.











**********      ¿Qué es REST?      **********

API REST es la combinación de las dos definiciones, para poder crear APIs que sigan un único estándar, que en este caso sería el estándar de Rest.

REST = Representational state transfer.

- Estilo de arquitectura para el diseño de interfaces web.
Esto significa que tanto API como REST no son implementaciones o tecnologías que podamos descargar e instalar en nuestro ordenador.
Basicamente son solo conceptos teóricos que debemos aplicar al momento en el que estemos escribiendo o estructurando nuestro proyecto.

- Permite el manejo de recursos desde el lado del servidor.
REST posee toda una serie de reglas que nosotros debemos seguir, permitiendonos manejar los recursos en todas las situaciones en las que debamos manejar o controlar recursos.

- REST es muy bueno ya que nos permite obtener un alto rendimiento, una buena escalabilidad,  mucha simplicidad a la hora de codificar nuestra API y mucha confiabilidad.


Basicamente Rest es un patrón que ya está comprobado, que funciona, y que se aplica a la gran mayoría de API que se construyen al día de hoy. 





PÁGINA 11: HTTP VERBS

Una de las reglas de REST es que debemos utilizar unos VERBS o unos verbos al momento en que hacemos un llamado HTTP para indicar a la API cuál es la acción que necesitamos ejecutar.

Si necesitamos Obtener y Leer recursos que se encuentran dentro del Servidor, sean recursos que esten en una base de datos o en un archivo debemos utilizar el VERBO GET.

Si necesitamos CREAR o realizar la inserción de un recurso de algún dato debemos utilizar el VERBO POST.

Si necesitamos realizar la ACTUALIZACION DE UN REGISTRO, debemos utilizar el método PUT.

Si necesitamos realizar la ACTUALIZACIÓN PARCIAL de un registro (es decir, actualizar solamente por ejemplo un campo o una columna de una tabla), utilizaremos el método PATCH.

Si necesitamos ELIMINAR un Registro, haremos uso del método DELETE.

Estos son los VERBOS mas utilizados para poder realizar acciones con recursos en base de datos o del lado del servidor en un API, pero existen tambien otros muy importantes.






PÁGINA 12: Manejo de URLs

Otra regla es la de manejar una URL por cada recurso que tengamos en la base de datos, esta URL nos va a permitir realzar las acciones que deseemos con este recurso, pero esta URL no puede ser dinámica, no puede cambiar y además debe indicar cuál es el recurso al que estamos accediendo.

Ejemplo: /api/usuarios/1

En este caso se está accediendo por ejemplo a la api, y a algun recurso como podría ser una tabla, el 1 al final indica el recurso 1 dentro de la tabla usuarios.

Esta URL no va a cambiar, y es la misma url que vamos a utilizar para todas las acciones que queramos realizar con este recurso. Si queremos eliminarlo, si queremos actualizarlo, si queremos obtenerlo vamos a tener que utilizar esta misma URL.





PAGINA 13 : RESPUESTAS HTTP

Por ultimo, Rest posee una serie de respuestas que nosotros debemos manejar para poder notificar al usuario de lo que está ocurriendo en nuestra API. Esto también nos permite manejar un estándar porque el concepto de API no nos dice qué es lo quedemos de devolver ya que simplemente estamos interactuando una aplicacion con otra, REST nos ayuda a poder manejar un estándar para poder manejar el tema de respuestas y comunicación entre una aplicación cliente y un servidor.

Tenemos diferentes respuestas que podemos manejar en una API REST:

- Respuestas Informativas (100 - 199), los códigos que van desde los 100 hasta los 199.

- Respuestas Satisfactorias (200 - 299), ESTAS SON LAS RESPUESTAS MAS UTILIZADAS.

- Redirecciones (300 - 399)

- Errores de los clientes (400 - 499), ALTAMENTE UTILIZADOS TAMBIÉN.

- Errores de los servidores (500 - 599) , ALTAMENTE UTILIZADOS TAMBIÉN ya que normalmente vamos a obtener este tipo de errores si existe una mala configuracion o un error interno dentro de la API.


Las respuestas mas utilizadas que podemos resaltar son 500 Internal Error que significa que ocurri+o un error interno dentro del Servidor, generalmente es un error no controlado, es decir, es algo que no debió pasar en el servidor pero que de alguna manera nunca se controló y nos devuelve un error y no puede controlar la accion que le estemos solicitando a nuestra API.



200 es el codigo exitoso, es el mas utilizado y es lo que esperamos que siempre ocurra dentro de una aplicacion indicando que todo esta funcionando bien.



NOT FOUND significa que el recurso no fue encontrado. Es bastante común también .



201 que indica que se ha creado un recurso, tambien es altamente utilizado.


204 el no content, que todo se realizó bien pero que no hay contenido para devolver. Esto se utiliza cuando se realiza tareas de actualizacion o cuando se realizan cambios dentro del servidor.











**********      Creando tu primera API con .NET      **********

Comandos desde la consola:

Una vez situado en la carpeta que vamos a utilizar para el proyecto podemos ejecutar los siguientes comandos:

° dotnet new = crea un proyecto de .NET basado en una plantilla.

Con este comando podemos crear diferentes proyectos, no solo APIs, sino tambien PROYECTOS DE CONSOLA, PROYECTOS PARA WINDOWS, PROYECTOS DE BLAZOR.


° dotnet new --list = para visualizar todas las planillas.

Desglozandose el listado, el comando que vamos a utilizar es "webapi"

Tambien existe otro diferente que es el "web" que permite crear una web api utilizando mínima la api, que es un concepto nuevo que posee .NET, sin embargo el TEMPLATE Clásico y el más completo es el "webapi"


Procedemos, desde la consola, a ejecutar el comando "dotnet new webapi" para que se cree nuestro proyecto.


Luego si deseamos abrir el proyecto con VScode desde la terminal podemos hacerlo con "code ." siempre y cuando estemos situados en el directorio correcto.


En la próxima sesión utilizaremos POSTMAN para poder analizar el ENDPOINT o la URL que trae por defecto la API, que sería como el DEMO que trae la API para que podamos jugar con ella y entender cómo funciona.











**********      Consumiendo API desde Postman      **********



15 extensiones indispensables para programar con C# y .NET Core

https://marketplace.visualstudio.com/items?itemName=jolhe.csharp-netcore-extensionpack

En esta clase ejecutaremos el proyecto que hemos creado anteriormente y utilizaremos POSTMAN para comprobar el funcionamiento de nuestra API.


Primeramente abrimos una nueva terminal para ejecutar el proyecto

ejecutamos el comando dotnet run

Al ejecutarlo nos saldrá los links a los cuales podremos consumir nuestra API.

Copiamos uno de los links (preferentemente la de https - con certificados seguros), y nos dirigimos a Postman.

Al abrir Postman agregamos un nuevo "Request" con el boton de "+".

Primero se determina qué acción o verbo realizar sobre la API, en este caso vamos a utilizar GET.

Luego pegamos el link que copiamos de VSCODE.

Una vez ingresada la direccion le damos click a SEND.

Al presionar SEND salta en STATUS "404 Not Found"

Lo cual quiere decir que la ruta a la que queremos acceder no posee ningún contenido, o no posee ninguna acción dentro de la API.

Por lo que debemos fijarnos dentro de la API cuál es la ruta a la que debemos acceder para realizar alguna acción.


Entonces volvemos a VSCODE.

Revisamos la carpeta "Controllers", esta carpeta contiene todas las clases que realizan el manejo de los request dentro de la API.

Alli nos fijamos en la instruccion ROUTE , para saber qué ruta utilizar para consumir el Endpoint.
En este caso recibe el mismo nombre del controlador "WeatherForecast", por lo que volvemos a Postman y a la direccion que ya habiamos copiado anteriormente le agregamos una barra y el nombre de la ruta ("WeatherForecast").

Quedando, por ejemplo : http://localhost:5087/WeatherForecast

Y volvemos a darle click a SEND.












**********      Análisis del Template para APIs de .NET      **********

Veamos un concepto fundamental "MVC"

Estas siglas significan:

MODEL = Datos
VIEW = Interfaz de usuario
Controller = Lógica

Es un Modelo Arquitectónico, MODELO VISTA CONTROLADOR ó MODEL CONTROLLER VIEW.

Es altamente utilizado dentro del desarrollo de software.

Nos ayuda a poder realizar una separacion de responsabilidades dentro de la estructura de nuestro proyecto.

La idea es crear "modelos" que son clases en la POO que nos permitiran almacenar los datos que nosotros en ese momento estemos manejando o que el usuario esté visualizando en ese momento a través de la VIEW.

La VIEW es esa Interfaz que va a tener nuestra aplicación para entenderse o comunicarse con el usuario.

El CONTROLLER maneja toda la lógica que se pueda presentar dentro de la interacción del usuario con la vista, por ejemplo al hacer click en un botón de "Guardar", cada una de las interacciones seran manejadas por los controladores.


ESTE PATRÓN ESTÁ MUY LIGADO AL DESARROLLO WEB ó APLICACIONES WEB.



En el caso del Template WEBAPI es eliminar la parte de la vista, es decir pasamos de MVC a MC:
MODEL (para almacenar los datos) y CONTROLLER (para manejar la lógica).

Recordemos que una API no tiene una interfaz de usuario, simplemente es una capa abstracta que permite que interactuemos con ella a través del patrón REST.

Lo común es que otros clientes, u otras APIS consuman los datos o ejecuten las diferentes funcionalidades que posee nuestra API.




VEAMOS LA ESTRUCTURA DEL PROYECTO QUE TENEMOS EN VISUAL STUDIO

"Todos los controladores deben almacenarse en la carpeta CONTROLLERS"

Por defecto, dentro de esta carpeta viene una clase llamada "WeatherForecastController"

Si nuestro proyecto tiene que manejar usuarios, procesos, areas, empleados, productos etc, lo que debemos realizar es crear un controlador para cada uno de esos modelos.

CADA MODELO CREADO DEBE TENER SU PROPIO CONTROLADOR.

Por ejemplo el MODELO WeatherForecast.cs tiene su CONTROLLADOR "WeatherForecastController.cs"


El modelo WeatherForecast.cs básicamente es una clase que posee cada una de las propiedades que necesita el demo para poder alojar la información, y WeatherForecastController.cs es el encargado de manejar toda la lógica poder devolver o retornar los datos y exponer todas las funciones que afecten de alguna manera el modelo WeatherForecast.cs


Es muy importante, para los controladores, agregar al final del nombre "Controller" como lo tenemos en el ejemplo: WeatherForecastController.cs


Además de esto, los controladores, deben heredar de ControllerBase que nos brinda todas las funciones que necesitamos para poder realizar todos los códigos de respuesta que normalmente se debería de responder, utilizando el patrón REST.


Otro archivo importante es la del proyecto con extensión .csproj

El TargetFramework es donde se define la versión del Framework

El SDK para el caso de WEBAPI siempre será web

El SDK posee una serie de librerías base que necesitamos para trabajar con alguna tecnología en particular.
En este caso la tecnología que vamos a manejar es ASP.NET que nos permite manejar requerimientos o peticiones http que son las que utilizan las Apis Rest.

el siguiente código:
<ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="7.0.10" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

Es un paquete que nos permite trabajar con ASP.NETCORE, y es el paquete que contiene la documentacion de "Swagger" que ya veremos qué es y para qué sirve, pero básicamente nos ayuda a generar la documentación de nuestra API.




PROGRAM.cs es el archivo que posee toda la configuración del proyecto y la forma en la que se va a ejecutar.




Por último, tenemos los archivos "appsettings.json" que por defecto crean el "appsettings.Development.json" y el"appsettings.json" que contiene todas las opciones para poder configurar nuestro proyecto.


Normalmente, en "appsettings.Development.json" vamos a almacenar la conexion a una base de datos, contraseñas, tockens de acceso para servicios en la nube, etc.



Luego dentro de la carpeta "Properties" se encuentra el archivo "launchSettings.json" que contiene como se va a ejecutar la API.

Siempre por defecto tiene dos perfiles: "webapi" y "IIS Express"













**********      Atributos para verbos HTTP      **********

¿Cómo podemos utilizar los verbos http dentro de nuestro proyecto?

Para realizar esto utilizaremos los Atributos que existen dentro de .NET

Nos permiten marcar en una función cuál es el verbo que queremos utilizar.


Vayamos para el código, lo primero que vamos a realizar es el método POST (para poder agregar un registro), en el archivo "WeatherForecastController.cs".



Alli creamos una nueva propiedad a la clase :

private static List<WeatherForecast> ListWeatherForecast = new List<WeatherForecast>();




Luego en el constructor de la clase le asignamos una serie de registros:


public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
        _logger = logger;
        /* El método Any devuelve un booleano, determina si tiene elementos u registros. En este caso en la condicion del if es si no tiene ningún registro. */
        if (ListWeatherForecast == null || !ListWeatherForecast.Any())
        {
            ListWeatherForecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                TemperatureC = Random.Shared.Next(-20, 55),
                Summary = Summaries[Random.Shared.Next(Summaries.Length)]
            })
        .ToList();
        }
    }





Al http get lo modificamos, ahora va a retornar la lista entera pero ya creada, a diferencia de la anterior, que por cada vez que de ejecutaba el método GET se creaban los registros aleatorios (Randoms), y luego los retornaba.

Asi quedó luego de las modificaciones:

[HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable<WeatherForecast> Get()
    {
        return ListWeatherForecast;

    }





Tambien creamos los métodos para POST y DELETE.


    /* Metodo POST: */
    [HttpPost]
    public IActionResult Post(WeatherForecast weatherForecast)
    {
        ListWeatherForecast.Add(weatherForecast);
        return Ok();
    }

    /* Metodo DELET: */
    [HttpDelete]
    public IActionResult Delete(int index)
    {
        ListWeatherForecast.RemoveAt(index);
        return Ok();

    }





Luego abrimos una nueva terminal y ejecutamos el proyecto.

Ejecutamos dotnet run
copiamos la url

Luego nos dirigimos a Postman, agregamos una nueva ventana, pegamos la url con el verbo POST, le damos click a Body / raw y en vez de "Text" que viene por defecto, elegimos JSON, que es el formato por el cual vamos a pasar los datos.

ESTA ES LA MANERA MÁS COMÚN DE PASAR LOS DATOS, ya que el formato JSON es el estándar.

Copiamos un fragmento del JSON que habiamos ejecutado en la ventana anterior en POSTMAN.

Por ejemplo este fragmento de JSON :

 {
        "date": "2023-12-09",
        "temperatureC": -14,
        "temperatureF": 7,
        "summary": "Warm"
    }




Para el DELETE, desde Postman, utilizamos la url "http://localhost:5087/WeatherForecast/1" en donde el 1 es el numero del indice que deseamos eliminar.














**********      Manejo de Rutas      **********


Aprendamos un poco mas respecto del manejo de las rutas utilizando el controlador que viene por defecto "WeatherForecastController".

Este código:
[Route("[controller]")]
es el que nos permite definir el enrutamiento de nuestro Controlador.


el [controller] define que es una ruta dinámica, si cambia el nombre del Controlador, entonces la ruta también se va a modificar.


Tambien podríamos agregar caracteres que sean estáticos, como por ejemplo:

[Route("api/[controller]")]

De manera que en este caso api queda fijo y el nombre dinámico del controlador para poder armar la ruta y acceder a los recursos.


Ahora abrimos una nueva terminal y ejecutamos "dotnet run", copiamos la url.

Si nos vamos a Postman e intentamos volver a ejecutar el GET de la clase anterior (sin cambiar nada), va a devolver error (404 Not Found), esto se debe a que la ruta para acceder al controlador ya no es la misma.

Antes era : http://localhost:5087/WeatherForecast

Mientras que ahora es : http://localhost:5087/api/WeatherForecast



Asi como podemos realizar el enrutamiento a nivel de Controlador, también podemos hacerlo a nivel de las acciones o métodos dentro del Controlador.

Por ejemplo al verbo GET podemos agregarle la ruta:
[Route("Get/weatherforecast")]

en este caso estamos especificando que la ruta dentro del Controlador ("api/[controller]"), tenemos que agregarle "Get/weatherforecast" para poder acceder al método GET.

Ejecutamos el dotnet run y verificamos esto en Postman.


Al irnos a Postman y ejecutamos el Verbo GET con la url http://localhost:5087/api/WeatherForecast va a funcionar igual ya que es el único método GET del Controlador.

Aún así si ejecutamos "http://localhost:5087/api/WeatherForecast/Get/weatherforecast" con el enrutamiento que recién definimos, también va a funcionar.




Podemos tener múltiples rutas para una acción.
Por ejemplo, recien creamos una ruta para el Verbo GET (  [Route("Get/weatherforecast")] )
Ahora podemos agregar una ruta adicional:   [Route("Get/weatherforecast2")]




También podemos utilizar una PALABRA DINÁMICA a la hora de enrutar acciones.

Para ello utilizamos la palabra [action]. Para los controladores utilizamos [controller].

Esto nos permite utilizar el nombre que tenga el método para realizar el llamado del endopoint.

De esta forma en Postman el GET se puede ejecutar de las siguientes maneras:

http://localhost:5087/api/WeatherForecast/Get/weatherforecast

http://localhost:5087/api/WeatherForecast/Get/weatherforecast2

http://localhost:5087/api/WeatherForecast/Get

Si cambiamos el nombre del metodo GET (desde VSCODE), entonces desde Postman tambien va a cambiar.


link ENRUTAMIENTO DE ATRIBUTOS : https://learn.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2















**********      Minimal API vs. Web API      **********

Son dos Templates que nos permite utilizar .NET

El Minimal API se lanzó recientemente 

- Nueva plantillacon un estilo minimalista. (Se utiliza una mínima cantidad de archivos para construir la API).
- Utiliza las últimas mejoras de C# y .NET para disminuir las líneas de código.
- Facilita la curva de aprendizaje de APIs en .NET.



Abrimos la terminal, creamos un directorio y dentro de él ejecutamos el comando "dotnet new web" para la creación del template.


Abrimos el directorio creado en VSCode.

Lo primero que se puede apreciar es que la carpeta de Controllers ya no existe.


En el Program.cs se han reducido las líneas de código y las configuraciones.

Dentro del Program.cs la siguiente linea:

app.MapGet("/", () => "Hello World!");

es la manera en la que mapear la API.


En la WEBAPI teníamos que crear un Controlador y utilizar los atributos para realizar los POSTs, el GET, etc, en este template realizamos el mapeo utilizando funciones.

Por ejemplo la función que viene por defecto:

app.MapGet("/", () => "Hello World!");

Realiza un GET.

Para realizar un POST podemos realizar lo siguiente:

app.MapPost()

Para Delete:

app.MapDelete()


Todo desde el archivo Program.cs




El MinimalApi esta preparado para proyecto pequeños/simples, ya cuando el proyecto sea grande, es decir, posea varios Endpoints,  lo ideal es utilizar el Template que vimos en clases anteriores, la WEBAPI.




CARACTERÍSTICAS MINIMAL API

- Utiliza mapeo de rutas con funciones.
- Orientado a proyectos pequeños, demos, microservicios y Azure functions.
- Complejo de escalar en proyectos de alta complejidad. El Program.cs va a crecer exponencialmente.



CARACTERÍSTICAS WEBAPIs

- Utiliza modelo MVC para estructurar el código. Sin utilizar la Vista (V), se crean Controladores, Modelos, dentro de los Controladores se crean las acciones que se necesitan.
- Se puede utilizar para proyectos de cualquier tamaño.
- Más sencillo de escalar.


















**********      ¿Qué son los Middlewares?      **********

- Es una serie de instrucciones de código que se agregan al ciclo de vida de una petición HTTP.
  Ya hemos realizado peticiones GET, POST. Cada vez que realizamos una petición, lo que sucede es que la petición va a ingresar en una línea de diferentes MIDDLEWARES que van afectar de alguna manera esa petición, van a realizar el procesamiento debido para devolver lo que el usuario está esperando.
Basicamente esto es lo que realizan los Middlewares, un tratamiento desde que inician los request hasta que devuelvan un resultado, ya sea un simple OK o información proveniente de la base de datos.

- Provee una ejecución de peticiones a través de capas.
  Esto nos permite entender muy bien cuál es la línea de tiempo que va a tener el Request desde su inicio hasta su fin, de esta manera podemos saber dónde queremos crear el Middleware o agregarlo para poder realizar ese cambio que buscamos dentro del Request.

- Facilitan la implementación de interceptores y filtros sobre las peticiones en una API.
  Con los Middlewares se facilita la visualización de la secuencia de comandos que se ejecutan por cada petición.
  A su vez podemos implementar Custom Middleware, es decir, Middlewares personalizados con el código que nosotros necesitemos para poder interceptar un Request y agregar algún comportamiento extra.





FUNCIONAMIENTO DE UN MIDDLEWARE:

Cada vez que se realiza un Request, este va a tener que pasar por todas las líneas de Middlewares que posee .NET.
A estas líneas de Middlewares se les llama Pipelines. Esto indica que va haber una secuencia de comandos que se deben ejecutar uno tras otro para poder completar 1 CICLO. Para este caso sería EL CICLO DE VIDA DEL REQUEST, desde que se incia hasta que responde.



El Orden de los Middlewares es MUY IMPORTANTE, ya que se deben ejecutar uno después del otro.

Es muy probable que exista una dependencia entre lo que realizó un Middleware anteriormente y lo que realizará el siguiente.



Una de las preguntas más frecuentes en las entrevistas laborales de .NET es en qué orden deben ir los Middlewares ó dónde se ubican los Custom Middlewares, deben estar antes del Middleware de Endpoints y después del Middleware de Autenticación y Autorización.
Este orden siempre se debe respetar ya que podríamos obtener comportamientos extraños o un mal manejo de las peticiones.




Procedemos a abrir nuestro proyecto en VSCODE.

Los Middlewares estan dentro del Program.cs

Una vez escrito el Middleware "app.UseWelcomePage();" hay que abrir una nueva terminal y ejecutar el proyecto.
Ejecutamos dotnet run
Copiamos la url y lo pegamos en el navegador donde nos saldrá la página de bienvenida.



















**********      Creando un nuevo Middleware      **********

Creamos un Middleware personalizado.

En VSCODE creamos una nueva carpeta "Middleware". Dentro de ella creamos "TimeMiddleware.cs" que no es ni más ni menos que una clase.

Lo que va a realizar es devolver la hora que el servidor tenga, sin importar cuál sea el Request que se esté realizando, sino simplemente se va a analizar el parámetro que venga dentro del Request.


 El método Invoke viene por defecto en todos los Middlewares.

Una vez creado Middleare/TimeMiddleware.cs y el app.MapControllers() en el Program.cs, abrimos una nueva terminal y ejecutamos "dotnet run" copiamos el http y nos dirigimos a Postman.

En el método GET pegamos la url, por ejemplo https://localhost:7182?time
estamos preguntando por el tiempo, y en el if creado en el Middleare/TimeMiddleware.cs es True por lo que retorna la hora.


A los efectos prácticos, al realizar un proyecto real, podríamos llegar a utilizar Middlewares como por ejemplo para realizar Logins o realizar una bitácora para todos los request que se estén realizando e interceptarlos y guardar la información, o inteceptar todos los request que han tenido errores y guardarlos en algún archivo o algún servicio para luego realizar análisis. Para todo esto los Middlewares son la mejor herramienta.


En la próxima clase aprenderemos un concepto que nos permitirá configurar todos los servicios, herramientas y demás que se utilizará dentro de nuestra aplicación para que facilmente podamos inyectarlos dentro de cada uno de los elementos o componentes que lo requieran y de esta manera poder tener un control general de todas las dependencias que posea nuestra aplicación.


También veremos porqué es una buena práctica implementar la "inyección de dependencias" en nuestro proyecto.



















**********      Inyección de dependencias      **********

Aprenderemos a cómo podemos inyectar dependencias dentro de nuestro WebApi.

La inyección de dependencias es un concepto altamente utilziados en lenguajes de programación orientados a objetos.

Nos permite utilizar diferentes tipos abstractos y configurar las dependencias utilizando un inyector y de esta manera nos evitamos tener que crear un nuevo objeto o una nueva referencia del componente cada vez que lo necesitemos sino que el inyector se encargaría de pasarnos esa dependencia y podemos utilizarla directamente dentro de los componentes que lo necesitemos ya sea una clase o un controlador en el caso de una WebApi.


Crearemos una dependencia muy sencilla y realizaremos todo el proceso desde la creación, la inyección y luego su utilización dentro de un controlador.




Vamos para VsCode:

Creamos una nueva carpeta, la vamos a llamar Services.

Creamos un "HelloworldService.cs" que será una clase. Dentro de ella creamos un método que retornará el Hello World.

Además vamos a crear una Interface (IHelloWorldService), que nos va ayudar a manejar un tipo abstracto que vamos a poder cambiar fácilmente luego, y nos ayudará a inyectar las dependencias.

Luego realizamos la configuración del inyector para que se pueda inyectar la dependencia.
Para ello vamos al Program, la dependencia la debemos establecer antes del "var app = builder.Build();"

Podemos utilizar "AddScoped<>", el cual crea una nueva instancia, de la dependencia utilizada, a nivel de controlador o a nivel de clase, es decir, no importa que estemos inyectando varias veces y en diferentes partes esta dependencia dentro de todo el contexto del controlador, o dentro de todo el contexto de la clase, se va a inyectar la misma implementación, es decir, la misma instancia que se creó para todo este elemento .

A su vez podemos utilizar "AddSingleton<>", el cual crea una única instancia de la dependencia a nivel de toda la API. No se recomienda utilizarlo ya que las dependencias se van a crear en memoria y esto podría ocasionar un problema además de no seguir la tendencia de implementar Apis que no manejen ningún tipo de estados sino que con cada Request se cree una nueva implementación o que se cree una nueva instancia de la dependencia que hemos configurado.

Lo recomendado es utilizar AddTransient, o el más utilizado AddScoped, ya que normalmente se inyecta la dependencia por el constructor del controlador.


//Cada vez que se inyecte la interface  IHelloWorldService  se va a crear un nuevo objeto de HelloWorldService internamente, es lo que va a realizar el inyector.
builder.Services.AddScoped<IHelloWorldService, HelloWorldService>();


Finalmente creamos un nuevo controlador que utilice esta dependencia que acabamos de configurar.

Para ello nos dirigimos a la carpeta de "Controllers", creamos un nuevo archivo "HelloWorldController.cs"


Copiamos del "WeatherForecastController" las siguientes líneas (ya que son indispensables para crear controladores):

using Microsoft.AspNetCore.Mvc;

namespace webapi.Controllers;

[ApiController]

[Route("api/[controller]")]



Otra cuestión importante es que el nombre de la clase debe finalizar con la palabra "Controller", y dicha clase heredar de "ControlBase".


Realizamos el dotnet run y nos dirijimos a Postman.


Utilizamos la misma url, realizamos un GET mediante "url/api/helloworld" al ejecutarlo nos va a devolver el OK y el HelloWorld desde la inyección de dependencia que establecimos mediante la interface y la clase.
Vemos lo fácil que es crear los servicios las herramientas y todo lo que queramos dentro de nuestro proyecto, podemos inyectar todas las que necesitemos, simplemente los separamos por comas dentro del constructor y poco a poco vamos agregando cada una de las dependencias y las vamos utilizando dentro del Controlador.




Ahora vamos a ver cómo podemos inyectar las dependencias sin utilizar una Interface sino directamente con una clase, esto no es una buena práctica, pero se suele utilizar cuando se requiere una conexión a una base de datos o conexión a servicios en donde s+i es importante utilizar "Scoped" ó "Transient" y utilizar Interfaces.

Vamos para VSCode, al Program.cs
Comentamos el Services que creamos:
builder.Services.AddScoped<IHelloWorldService, HelloWorldService>();

Tipeamos:
builder.Services.AddScoped<IHelloWorldService>(p=> new HelloWorldService());

Que es la manera de inyectar directamente por la clase, sin hacer uso de las interfaces.

Luego ejecutamos dotnet run y lo probamos en Postman.




En la siguiente clase veremos el concepto de Login, que basicamente nos permite escibir diferentes tipos de mensajes, incluyendo errores, dentro de la consola para poder realizar un monitoreo de al aplicación y poder entender qué está ocurriendo internamente, sobre todo cuando se tenga errores no controlados.



















**********      Agregando Logging a API      **********


El Logging nos permite realizar una trazabilidad de lo que está ocurriendo dentro de la API.

Lleva un registro de las acciones.

Podemos agregarlo en cualquier punto, en cualquier funcionalidad que tengamos dentro de la API, ya sea en un controlador o en una clase en específica.



Nos dirigimos a VSCode.

En nuestro controlador "WeatherForecastController.cs" tenemos una implementación de Logging:

private readonly ILogger<WeatherForecastController> _logger;


y lo recibe por el constructor:

 public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
        _logger = logger;
}



Una vez recibido en el constructor, ya podemos utilizarlo en cualquier parte de la aplicación.




En nuestro método GET() agregamos los siguiente:

_logger.LogInformation("Retornando la lista de weatherforecast");

informamos que la lista está siendo retornada.

Este mensaje aparece en la Terminal, cuando ejecutamos el proyecto, por ende también será visible para los diferentes servicios que utilicemos, por ejemplo cuando publiquemos la API en un contenedor en la nube.

Esto es muy importante para cuando la Aplicación esté en la nube y queramos saber qué está ocurriendo cuando se detecte un error o cuando haya una secuencia muy compleja de comandos que necesitemos manejar para poder entender que está ocurriendo internamente.



Como reto realizaremos lo mismo en HelloWorldController.cs

Agregarmos un logger dentro de las propiedades, la recibimos por el constructor, y en el método GET():

logger.LogInformation("Retornando 'Hello World'.");










































































